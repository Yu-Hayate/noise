{"entries":[{"timestamp":1745254850870,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":157,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":2,"length1":21,"diffs":[[1,"    \"name\": \"noie\",\n"]]},{"start1":67,"length1":136,"diffs":[[1,"        \"device\": \"*\"\n"]]},{"start1":174,"length1":43,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":203,"length1":75,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"noise_.ts","value":"enum NoiseType {\n    //% block=\"Perlin\"\n    Perlin,\n    //% block=\"Static\"\n    Static\n}\nlet nodes: number = 12\nlet gradients: { x: number; y: number }[][] = [];\nlet currentRng: FastRandomBlocks = Random.createRNG(Math.randomRange(0x00000001, 0xFFFFFFFF));\n\n//% color=\"#556B2F\"\nnamespace Noise {\n    /**\n     * Sets the random number generator for noise generation\n     * @param rng The FastRandomBlocks instance to use for seeded randomness\n     */\n    //% block=\"set noise seed to $rng\"\n    //% rng.defl=rng\n    //% rng.shadow=variables_get\n    export function setSeed(rng: FastRandomBlocks) {\n        currentRng = rng;\n    }\n\n    /**\n     * Generates a noise map based on the specified noise type.\n     * @param noiseType Type of noise to generate (Perlin or Static).\n     * @param width The width of the noise map.\n     * @param height The height of the noise map.\n     * @returns A 2D array representing the generated noise map.\n     */\n    //% block=\"create $noiseType noise map width $width height $height || scale $scale \"\n    //% blockSetVariable=noiseMap\n    //% width.defl=160\n    //% height.defl=120\n    //% scale.defl=4\n    //% inlineInputMode=inline\n    export function createNoiseMap(noiseType: NoiseType, width: number, height: number, scale?: number): number[][] {\n        // Make sure we have an RNG - if not, create a default one\n        if (!currentRng) {\n            currentRng = new FastRandomBlocks(1234); // Default seed\n        }\n\n        switch (noiseType) {\n            case NoiseType.Perlin:\n                nodes = scale || 4;\n                initialize_gradients();\n                return generate_perlin_noise(width, height);\n                break;\n            case NoiseType.Static:\n                return generate_static_noise(width, height);\n                break;\n            default:\n                return [];\n                break\n        }\n    }\n\n    /**\n     * Converts a noise map into an image and sets it as the background.\n     * @param noiseMap A 2D array representing the noise map to be visualized.\n     */\n    //% block=\"convert $noiseMap to image\"\n    //% noiseMap.defl=noiseMap\n    //% noiseMap.shadow=variables_get\n    export function noiseToImage(noiseMap: number[][]): Image {\n        const h: number = noiseMap.length; // Height of the noise map\n        const w: number = noiseMap[0].length; // Width of the noise map\n        let noise: Image = image.create(w, h);\n        for (let y = 0; y < h; y++) {\n            for (let x = 0; x < w; x++) {\n                let color = Math.floor(noiseMap[y][x] * 15) + 1; // Map to color range\n                noise.setPixel(x, y, color);\n            }\n        }\n        return noise;\n    }\n\n    // Helper function that uses the seeded RNG instead of Math.random()\n    export function seeded_random(): number {\n        // Get a number between 0 and 65535, then normalize to 0-1\n        return currentRng.nextNumber() / 65535;\n    }\n\n    export function random_unit_vector() {\n        let theta = seeded_random() * 2 * Math.PI;\n        return { x: Math.cos(theta), y: Math.sin(theta) };\n    }\n\n    export function initialize_gradients() {\n        gradients = [];\n        for (let i = 0; i < nodes; i++) {\n            let row = [];\n            for (let j = 0; j < nodes; j++) {\n                row.push(random_unit_vector());\n            }\n            gradients.push(row);\n        }\n    }\n\n    export function dot_prod_grid(x: number, y: number, vert_x: number, vert_y: number): number {\n        let g_vect = gradients[vert_y][vert_x];\n        let d_vect = { x: x - vert_x, y: y - vert_y };\n        return d_vect.x * g_vect.x + d_vect.y * g_vect.y;\n    }\n\n    export function smootherstep(x: number): number {\n        return 6 * x ** 5 - 15 * x ** 4 + 10 * x ** 3;\n    }\n\n    export function interp(x: number, a: number, b: number): number {\n        return a + smootherstep(x) * (b - a);\n    }\n\n    export function perlin_get(x: number, y: number): number {\n        let x0 = Math.floor(x);\n        let x1 = x0 + 1;\n        let y0 = Math.floor(y);\n        let y1 = y0 + 1;\n\n        let sx = x - x0;\n        let sy = y - y0;\n\n        let n0 = dot_prod_grid(x, y, x0, y0);\n        let n1 = dot_prod_grid(x, y, x1, y0);\n        let ix0 = interp(sx, n0, n1);\n\n        n0 = dot_prod_grid(x, y, x0, y1);\n        n1 = dot_prod_grid(x, y, x1, y1);\n        let ix1 = interp(sx, n0, n1);\n\n        return (interp(sy, ix0, ix1) + 1) / 2;\n    }\n\n    export function generate_perlin_noise(width: number, height: number): number[][] {\n        let noise: number[][] = [];\n        for (let y = 0; y < height; y++) {\n            let row = [];\n            for (let x = 0; x < width; x++) {\n                row.push(perlin_get(x / width * (nodes - 1), y / height * (nodes - 1)));\n            }\n            noise.push(row);\n        }\n        return noise;\n    }\n\n    export function generate_static_noise(width: number, height: number): number[][] {\n        const noise: number[][] = [];\n\n        for (let y = 0; y < height; y++) {\n            const row: number[] = [];\n            for (let x = 0; x < width; x++) {\n                // Use seeded random instead of Math.random()\n                const randomValue = seeded_random();\n                row.push(randomValue);\n            }\n            noise.push(row);\n        }\n\n        return noise;\n    }\n}"}]}],"snapshots":[{"timestamp":1745254850869,"editorVersion":"2.0.48","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"noie\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1745254989030}